# ðŸ›ï¸ EasyShop - Modern E-commerce Platform

[![Next.js](https://img.shields.io/badge/Next.js-14.1.0-black?style=flat-square&logo=next.js)](https://nextjs.org/)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.0.0-blue?style=flat-square&logo=typescript)](https://www.typescriptlang.org/)
[![MongoDB](https://img.shields.io/badge/MongoDB-8.1.1-green?style=flat-square&logo=mongodb)](https://www.mongodb.com/)
[![Redux](https://img.shields.io/badge/Redux-2.2.1-purple?style=flat-square&logo=redux)](https://redux.js.org/)
[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

EasyShop is a modern, full-stack e-commerce platform built with Next.js 14, TypeScript, and MongoDB. It features a beautiful UI with Tailwind CSS, secure authentication, real-time cart updates, and a seamless shopping experience.

## âœ¨ Features

- ðŸŽ¨ Modern and responsive UI with dark mode support
- ðŸ” Secure JWT-based authentication
- ðŸ›’ Real-time cart management with Redux
- ðŸ“± Mobile-first design approach
- ðŸ” Advanced product search and filtering
- ðŸ’³ Secure checkout process
- ðŸ“¦ Multiple product categories
- ðŸ‘¤ User profiles and order history
- ðŸŒ™ Dark/Light theme support

## ðŸ—ï¸ Architecture

EasyShop follows a three-tier architecture pattern:

### 1. Presentation Tier (Frontend)

- Next.js React Components
- Redux for State Management
- Tailwind CSS for Styling
- Client-side Routing
- Responsive UI Components

### 2. Application Tier (Backend)

- Next.js API Routes
- Business Logic
- Authentication & Authorization
- Request Validation
- Error Handling
- Data Processing

### 3. Data Tier (Database)

- MongoDB Database
- Mongoose ODM
- Data Models
- CRUD Operations
- Data Validation

## CICD Architecture

![](./public/EasyShop_CICD_Workflow_Architecture.png)

## ðŸš€ Infrastructure & DevOps

The EasyShop platform is built with modern DevOps practices and includes:

### Infrastructure Components

- **AWS Cloud Platform**: Leveraging EKS, EC2, VPC, and more
- **Terraform**: Infrastructure as Code for consistent environment setup
- **Kubernetes**: Container orchestration for scalable deployments
- **HashiCorp Vault**: Secure secrets management with high availability
- **Monitoring Stack**: Prometheus, Grafana, and Loki for comprehensive monitoring

### ðŸ—‚ï¸ DevOps Project Structure

```
easyshop/
â”œâ”€â”€ ansible/                          # Configuration management
â”‚   â”œâ”€â”€ inventory/                    # Host inventory files
â”‚   â”‚   â”œâ”€â”€ production                # Production environment hosts
â”‚   â”‚   â””â”€â”€ staging                   # Staging environment hosts
â”‚   â”œâ”€â”€ playbooks/                    # Ansible playbooks
â”‚   â”‚   â”œâ”€â”€ setup_jenkins.yml         # Jenkins server setup
â”‚   â”‚   â”œâ”€â”€ setup_monitoring.yml      # Prometheus & Grafana setup
â”‚   â”‚   â”œâ”€â”€ setup_bastion.yml         # Bastion host configuration
â”‚   â”‚   â””â”€â”€ deploy_app.yml            # Application deployment
â”‚   â””â”€â”€ roles/                        # Reusable Ansible roles
â”‚       â”œâ”€â”€ common/                   # Common server setup
â”‚       â”œâ”€â”€ docker/                   # Docker installation
â”‚       â”œâ”€â”€ jenkins/                  # Jenkins configuration
â”‚       â””â”€â”€ monitoring/               # Monitoring stack setup
â”‚
â”œâ”€â”€ docker/                           # Docker configurations
â”‚   â”œâ”€â”€ Dockerfile                    # Main application Dockerfile
â”‚   â”œâ”€â”€ docker-compose.yml            # Local development setup
â”‚   â”œâ”€â”€ .dockerignore                 # Docker ignore file
â”‚   â””â”€â”€ docker-entrypoint.sh          # Container entrypoint script
â”‚
â”œâ”€â”€ jenkins/                          # Jenkins CI/CD configuration
â”‚   â”œâ”€â”€ Jenkinsfile                   # Main pipeline definition
â”‚   â”œâ”€â”€ scripts/                      # Jenkins pipeline scripts
â”‚   â”‚   â”œâ”€â”€ build.sh                  # Build script
â”‚   â”‚   â”œâ”€â”€ test.sh                   # Test script
â”‚   â”‚   â””â”€â”€ deploy.sh                 # Deployment script
â”‚   â””â”€â”€ shared-libraries/             # Jenkins shared libraries
â”‚       â””â”€â”€ vars/                     # Pipeline shared functions
â”‚           â”œâ”€â”€ dockerBuild.groovy    # Docker build function
â”‚           â”œâ”€â”€ slackNotify.groovy    # Slack notification function
â”‚           â””â”€â”€ updateManifest.groovy # K8s manifest update function
â”‚
â”œâ”€â”€ kubernetes/                       # Kubernetes manifests
â”‚   â”œâ”€â”€ applications/                 # Application manifests
â”‚   â”‚   â”œâ”€â”€ 00-namespace.yaml         # EasyShop namespace
â”‚   â”‚   â”œâ”€â”€ 01-mongodb-pv.yaml        # MongoDB persistent volume
â”‚   â”‚   â”œâ”€â”€ 02-mongodb-pvc.yaml       # MongoDB persistent volume claim
â”‚   â”‚   â”œâ”€â”€ 03-configmap.yaml         # Application configuration
â”‚   â”‚   â”œâ”€â”€ 04-secrets.yaml           # Application secrets
â”‚   â”‚   â”œâ”€â”€ 05-mongodb-service.yaml   # MongoDB service
â”‚   â”‚   â”œâ”€â”€ 06-mongodb-statefulset.yaml # MongoDB stateful set
â”‚   â”‚   â”œâ”€â”€ 07-easyshop-deployment.yaml # EasyShop application deployment
â”‚   â”‚   â”œâ”€â”€ 08-easyshop-service.yaml  # EasyShop service
â”‚   â”‚   â”œâ”€â”€ 09-ingress.yaml           # Ingress configuration
â”‚   â”‚   â””â”€â”€ 10-hpa.yaml               # Horizontal pod autoscaler
â”‚   â”‚
â”‚   â”œâ”€â”€ monitoring/                   # Monitoring stack manifests
â”‚   â”‚   â”œâ”€â”€ namespace.yaml            # Monitoring namespace
â”‚   â”‚   â”œâ”€â”€ prometheus/               # Prometheus configuration
â”‚   â”‚   â”œâ”€â”€ grafana/                  # Grafana configuration
â”‚   â”‚   â”œâ”€â”€ alertmanager/             # Alertmanager configuration
â”‚   â”‚   â””â”€â”€ loki/                     # Loki configuration
â”‚   â”‚
â”‚   â””â”€â”€ vault/                        # Vault Kubernetes integration
â”‚       â””â”€â”€ vault-config.yaml         # Vault Kubernetes configuration
â”‚
â””â”€â”€ terraform/                        # Infrastructure as Code
    â”œâ”€â”€ environments/                 # Environment-specific configurations
    â”‚   â”œâ”€â”€ dev/                      # Development environment
    â”‚   â”œâ”€â”€ staging/                  # Staging environment
    â”‚   â””â”€â”€ prod/                     # Production environment
    â”œâ”€â”€ modules/                      # Reusable Terraform modules
    â”‚   â”œâ”€â”€ networking/               # VPC and networking module
    â”‚   â”œâ”€â”€ eks/                      # EKS cluster module
    â”‚   â”œâ”€â”€ ec2/                      # EC2 instances module
    â”‚   â””â”€â”€ vault/                    # Vault infrastructure module
    â”œâ”€â”€ main.tf                       # Main Terraform configuration
    â”œâ”€â”€ variables.tf                  # Variable definitions
    â”œâ”€â”€ outputs.tf                    # Output definitions
    â””â”€â”€ templates/                    # User data templates
        â”œâ”€â”€ bastion_user_data.tpl     # Bastion host setup script
        â””â”€â”€ vault_user_data.tpl       # Vault server setup script
```

## Prerequisites

> [!IMPORTANT]  
> Before you begin setting up this project, make sure the following tools are installed and configured properly on your system:

- **Terraform** (v1.5.0+)
- **AWS CLI** (configured with appropriate credentials)
- **kubectl** (for Kubernetes management)
- **Helm** (v3+)
- **Git**
- **Docker**

## Setup & Initialization <br/>

### 1. Install Terraform

- Install Terraform<br/>

#### Linux & macOS

```bash
curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"
sudo apt-get update && sudo apt-get install terraform
```

### Verify Installation

```bash
terraform -v
```

### Initialize Terraform

```bash
terraform init
```

### 2. Install AWS CLI

AWS CLI (Command Line Interface) allows you to interact with AWS services directly from the command line.

```bash
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
sudo apt install unzip
unzip awscliv2.zip
sudo ./aws/install
```

`aws configure`

> #### This will prompt you to enter:<br/>

- **AWS Access Key ID:**<br/>
- **AWS Secret Access Key:**<br/>
- **Default region name:**<br/>
- **Default output format:**<br/>

> [!NOTE]
> Make sure the IAM user you're using has the necessary permissions. You'll need an AWS IAM Role with programmatic access enabled, along with the Access Key and Secret Key.

## Getting Started

> Follow the steps below to get your infrastructure up and running using Terraform:<br/>

1. **Clone the Repository:**
   First, clone this repo to your local machine:<br/>

```bash
git clone https://github.com/LondheShubham153/tws-e-commerce-app.git
cd terraform
```

2. **Generate SSH Key Pair:**
   Create a new SSH key to access your EC2 instance:

```bash
ssh-keygen -f terra-key
```

This will prompt you to create a new key file named terra-key.

3. **Private key permission:** Change your private key permission:

```bash
chmod 400 terra-key
```

4. **Initialize Terraform:**
   Initialize the Terraform working directory to download required providers:

```bash
terraform init
```

5. **Review the Execution Plan:**
   Before applying changes, always check the execution plan:

```bash
terraform plan
```

6. **Apply the Configuration:**
   Now, apply the changes and create the infrastructure:

```bash
terraform apply
```

> Confirm with `yes` when prompted.

7. **Access Your EC2 Instance;** <br/>
   After deployment, grab the public IP of your EC2 instance from the output or AWS Console, then connect using SSH:

```bash
ssh -i terra-key ubuntu@<public-ip>
```

8. **Update your kubeconfig:**
   Configure kubectl to interact with your EKS cluster:
   > [!CAUTION]
   > You need to configure aws cli first to execute this command:

```bash
aws configure
```

```bash
aws eks --region eu-west-1 update-kubeconfig --name tws-eks-cluster
```

9. **Check your cluster:**

```bash
kubectl get nodes
```

## ðŸ“Š Monitoring & Observability

EasyShop includes a comprehensive monitoring stack:

### Components

- **Prometheus**: For metrics collection and alerting
- **Grafana**: For visualization of metrics with prebuilt dashboards
- **Loki**: For log aggregation and querying
- **Alertmanager**: For alert management and notifications

### Features

- Real-time performance dashboards for the application and infrastructure
- Predefined alerts for critical system events
- Centralized logging for troubleshooting
- Custom dashboards for business metrics

### Deployment

The monitoring stack is deployed as Kubernetes resources:

```bash
kubectl apply -f kubernetes/monitoring/namespace.yaml
kubectl apply -f kubernetes/monitoring/prometheus/
kubectl apply -f kubernetes/monitoring/grafana/
kubectl apply -f kubernetes/monitoring/loki/
kubectl apply -f kubernetes/monitoring/alertmanager/
```

### Access Monitoring Tools

After deployment, you can access:

- Grafana: https://grafana.easyshop.internal
- Prometheus: https://prometheus.easyshop.internal
- Alertmanager: https://alertmanager.easyshop.internal

## ðŸ” Vault Integration

EasyShop uses HashiCorp Vault for secure secrets management:

### Features

- High-availability Vault cluster
- Auto-unsealing with AWS KMS
- Integration with Kubernetes
- Dynamic database credentials
- Encrypted secrets storage

### Deployment

Vault is deployed using Terraform for the infrastructure and Kubernetes for service integration:

```bash
kubectl apply -f kubernetes/vault/
```

## Jenkins Setup Steps

> [!TIP]
> Check if jenkins service is running:

```bash
sudo systemctl status jenkins
```

## Steps to Access Jenkins & Install Plugins

#### 1. **Open Jenkins in Browser:**

> Use your public IP with port 8080:
> **http://<public_IP>:8080**

#### 2. **Initial Admin password:**

> Start the service and get the Jenkins initial admin password:
>
> ```bash
> sudo cat /var/lib/jenkins/secrets/initialAdminPassword
> ```

#### 3. **Start Jenkins (_If Not Running_):**

> Get the Jenkins initial admin password:
>
> ```bash
> sudo systemctl enable jenkins
> sudo systemctl restart jenkins
> ```

#### 4. **Install Essential Plugins:**

> - Navigate to:
>   **Manage Jenkins â†’ Plugins â†’ Available Plugins**<br/>
> - Search and install the following:<br/>
>   - **Docker Pipeline**<br/>
>   - **Pipeline View**

#### 5. **Set Up Docker & GitHub Credentials in Jenkins (Global Credentials)**<br/>

> - GitHub Credentials:
>   - Go to:
>     **Jenkins â†’ Manage Jenkins â†’ Credentials â†’ (Global) â†’ Add Credentials**
> - Use:
>   - Kind: **Username with password**
>   - ID: **github-credentials**<br/>

> - DockerHub Credentials:
>   Go to the same Global Credentials section
> - Use:
>   - Kind: **Username with password**
>   - ID: **docker-hub-credentials** > [Notes:]
>     Use these IDs in your Jenkins pipeline for secure access to GitHub and DockerHub

#### 6. Jenkins Shared Library Setup:

> - `Configure Trusted Pipeline Library`:
>
>   - Go to:
>     **Jenkins â†’ Manage Jenkins â†’ Configure System**
>     Scroll to Global Pipeline Libraries section
>
> - **Add a New Shared Library:**
> - **Name:** shared
> - **Default Version:** main
> - **Project Repository URL:** `https://github.com/<your user-name/jenkins-shared-libraries`.
>
> [Notes:]
> Make sure the repo contains a proper directory structure eq: vars/<br/>

#### 7. Setup Pipeline<br/>

> - Create New Pipeline Job<br/>
>   - **Name:** EasyShop<br/>
>   - **Type:** Pipeline<br/>
>     Press `Okey`<br/>

> > In **General**<br/>
> >
> > - **Description:** EasyShop<br/>
> > - **Check the box:** `GitHub project`<br/>
> > - **GitHub Repo URL:** `https://github.com/<your user-name/tws-e-commerce-app`<br/>
>
> > In **Trigger**<br/>
> >
> > - **Check the box:**`GitHub hook trigger for GITScm polling`<br/>
>
> > In **Pipeline**<br/>
> >
> > - **Definition:** `Pipeline script from SCM`<br/>
> > - **SCM:** `Git`<br/>
> > - **Repository URL:** `https://github.com/<your user-name/tws-e-commerce-app`<br/>
> > - **Credentials:** `github-credentials`<br/>
> > - **Branch:** master<br/>
> > - **Script Path:** `Jenkinsfile`<br/>

#### **Fork Required Repos**<br/>

> > Fork App Repo:<br/>
> >
> > - Open the `Jenkinsfile`<br/>
> > - Change the DockerHub username to yours<br/>
>
> > **Fork Shared Library Repo:**<br/>
> >
> > - Edit `vars/update_k8s_manifest.groovy`<br/>
> > - Update with your `DockerHub username`<br/>
>
> > **Setup Webhook**<br/>
> > In GitHub:<br/>
> >
> > - Go to **`Settings` â†’ `Webhooks`**<br/>
> > - Add a new webhook pointing to your Jenkins URL<br/>
> > - Select: **`GitHub hook trigger for GITScm polling`** in Jenkins job<br/>
>
> > **Trigger the Pipeline**<br/>
> > Click **`Build Now`** in Jenkins

#### **8. CD â€“ Continuous Deployment Setup**<br/>

**Prerequisites:**<br/>
Before configuring CD, make sure the following tools are installed:<br/>

- Installations Required:<br/>
  **kubectl**<br/>
  **AWS CLI**

**SSH into Bastion Server**<br/>

- Connect to your Bastion EC2 instance via SSH.

**Note:**<br/>
This is not the node where Jenkins is running. This is the intermediate EC2 (Bastion Host) used for accessing private resources like your EKS cluster.

**8. Configure AWS CLI on Bastion Server**
Run the AWS configure command:<br/>

```bash
aws configure
```

Add your Access Key and Secret Key when prompted.

**9. Update Kubeconfig for EKS**<br/>
Run the following important command:

```bash
aws eks update-kubeconfig --region eu-west-1 --name tws-eks-cluster
```

- This command maps your EKS cluster with your Bastion server.
- It helps to communicate with EKS components.

**10. Argo CD Setup**<br/>
Create a Namespace for Argo CD<br/>

```bash
kubectl create namespace argocd
```

1. Install Argo CD using Manifest

```bash
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
```

2. Watch Pod Creation

```bash
watch kubectl get pods -n argocd
```

3. This helps monitor when all Argo CD pods are up and running.<br/>

4. Check Argo CD Services

```bash
kubectl get svc -n argocd
```

5. Change Argo CD Server Service to NodePort

```bash
kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "NodePort"}}'
```

11. Access Argo CD GUI<br/>
    Check Argo CD Server Port (again, post NodePort change)<br/>

```bash
kubectl get svc -n argocd
```

1. Port Forward to Access Argo CD in Browser<br/>
   Forward Argo CD service to access the GUI:

```bash
kubectl port-forward svc/argocd-server -n argocd <your-port>:443 --address=0.0.0.0 &
```

2. Replace <your-port> with a local port of your choice (e.g., 8080).<br/>
   Now, open https://<bastion-ip>:<your-port> in your browser.

Get the Argo CD Admin Password<br/>

```bash
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo
```

1. Log in to the Argo CD GUI

- Username: admin
- Password: (Use the decoded password from the previous command)

2. Update Your Password

- On the left panel of Argo CD GUI, click on "User Info"
- Select Update Password and change it.

### **Deploy Your Application in Argo CD GUI**<br/>

> 1. On the Argo CD homepage, click on the "New App" button.<br/>

> 2. Fill in the following details:<br/>
>
> - **Application Name:** > `Enter your desired app name`
> - **Project Name:**
>   Select `default` from the dropdown.

> 3. In the `Source` section:
>
> - **Repo URL:**
>   Add the Git repository URL that contains your Kubernetes manifests.
> - **Path:** > `Kubernetes` (or the actual path inside the repo where your manifests reside)

> 4. In the "Destination" section:
>
> - **Cluster URL:** > https://kubernetes.default.svc (usually shown as "default")
> - **Namespace:**
>   tws-e-commerce-app (or your desired namespace)

> 5. Click on "Create".

## Nginx ingress controller:<br/>

> 1. Install the Nginx Ingress Controller using Helm:

```bash
kubectl create namespace ingress-nginx
```

> 2. Add the Nginx Ingress Controller Helm repository:

```bash
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
```

> 3. Install the Nginx Ingress Controller:

```bash
helm install nginx-ingress ingress-nginx/ingress-nginx \
  --namespace ingress-nginx \
  --set controller.service.type=LoadBalancer
```

> 4. Check the status of the Nginx Ingress Controller:

```bash
kubectl get pods -n ingress-nginx
```

> 5. Get the external IP address of the LoadBalancer service:

```bash
kubectl get svc -n ingress-nginx
```

## Install Cert-Manager

> 1. **Jetpack:** Add the Jetstack Helm repository:

```bash
helm repo add jetstack https://charts.jetstack.io
helm repo update
```

> 2. **Cert-Manager:** Install the Cert-Manager Helm chart:

```bash
helm install cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --version v1.12.0 \
  --set installCRDs=true
```

> 3. **Check pods:**Check the status of the Cert-Manager pods:

```bash
kubectl get pods -n cert-manager
```

> 4. **DNS Setup:** Find your DNS name from the LoadBalancer service:

```bash
kubectl get svc nginx-ingress-ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
```

> 5. Create a DNS record for your domain pointing to the LoadBalancer IP.
>
> - Go to your godaddy dashboard and create a new CNAME record and map the DNS just your got in the terminal.

### **HTTPS:**

> #### 1. **Update your manifests to enable HTTPS:**
>
> > `04-configmap.yaml`
> >
> > ```bash
> > apiVersion: v1
> > kind: ConfigMap
> > metadata:
> >   name: easyshop-config
> >   namespace: easyshop
> > data:
> >   MONGODB_URI: "mongodb://mongodb-service:27017/easyshop"
> >   NODE_ENV: "production"
> >   NEXT_PUBLIC_API_URL: "https://easyshop.letsdeployit.com/api"
> >   NEXTAUTH_URL: "https://easyshop.letsdeployit.com/"
> >   NEXTAUTH_SECRET: "HmaFjYZ2jbUK7Ef+wZrBiJei4ZNGBAJ5IdiOGAyQegw="
> >   JWT_SECRET: "e5e425764a34a2117ec2028bd53d6f1388e7b90aeae9fa7735f2469ea3a6cc8c"
> > ```

> #### 2. **Update your manifests to enable HTTPS:**
>
> > `10-ingress.yaml`
> >
> > ```bash
> > apiVersion: networking.k8s.io/v1
> > kind: Ingress
> > metadata:
> >   name: easyshop-ingress
> >   namespace: easyshop
> >   annotations:
> >     nginx.ingress.kubernetes.io/proxy-body-size: "50m"
> >     kubernetes.io/ingress.class: "nginx"
> >     cert-manager.io/cluster-issuer: "letsencrypt-prod"
> >     nginx.ingress.kubernetes.io/ssl-redirect: "true"
> > spec:
> >   tls:
> >   - hosts:
> >     - easyshop.letsdeployit.com
> >     secretName: easyshop-tls
> >   rules:
> >   - host: easyshop.letsdeployit.com
> >     http:
> >       paths:
> >       - path: /
> >         pathType: Prefix
> >         backend:
> >           service:
> >             name: easyshop-service
> >             port:
> >               number: 80
> > ```

> #### 3. **Apply your manifests:**
>
> ```bash
> kubectl apply -f 00-cluster-issuer.yaml
> kubectl apply -f 04-configmap.yaml
> kubectl apply -f 10-ingress.yaml
> ```

> #### 4. **Commands to check the status:**
>
> > ```bash
> > kubectl get certificate -n easyshop
> > ```

> > ```bash
> > kubectl describe certificate easyshop-tls -n easyshop
> > ```
>
> > ```bash
> > kubectl logs -n cert-manager -l app=cert-manager
> > ```
>
> > ```bash
> > kubectl get challenges -n easyshop
> > ```

> > ```bash
> > kubectl describe challenges -n easyshop
> > ```

## **Congratulations!** <br/>

![EasyShop Website Screenshot](./public/Deployed.png)

### Your project is now deployed.
